using System.Text;

namespace YandexConstestsDotNet;

public class Program
{
    static void Main(string[] args)
    {
        //Чтение первой строки, получение количества вершин и рёбер.
        var dimensions = Console.ReadLine()!.Split(' ');
        var size = int.Parse(dimensions[0]);
        var connectionCount = int.Parse(dimensions[1]);

        //Чтение рёбер, запись в список элементов типа Connection.
        //Connection - структура, которая содержит в себе две переменные типа int,
        //которые представляют из себя номера связанных вершин.
        var connections = new List<Connection>(connectionCount);
        for (int _ = 0; _ < connectionCount; _++)
        {
            var connection = Console.ReadLine()!.Split(' ');
            connections.Add(new Connection(int.Parse(connection[0]), int.Parse(connection[1])));
        }

        //Создаётся граф на основании списка рёбер и количества вершин,
        //затем передаётся в функцию которая находит ответ. 
        var graph = new Graph(connections, size);

        //Еденица вторым аргументом - номер вершины, которую надо найти.
        //Функция возращает SortedSet<int> - бинарное дерево (красно-чёрное под копотом),
        //состоящее из номеров вершин найденной комноненты связности.
        var result = GraphAlgorithms.SearchElementByDfs(graph, 1);

        //Проверка результата на отсутствие найденой вершины, вывод 0 и завершение выполнения.
        //Вряд ли это возможно, так как в условии написано, что нумерация вершин начинается с 1,
        //то есть даже если эта вершина ни с кем не будет связана,
        //то по идее как минимум она одна должна быть в ответе.
        if (result.Count == 0)
        {
            Console.WriteLine(0);
            return;
        }

        //Вывод результата.
        var sb = new StringBuilder();
        //Итерирование по SortedSet идёт от самого меньшего элемента к самомоу большему.
        foreach (var id in result) sb.Append(id).Append(' ');
        Console.WriteLine(result.Count);
        Console.WriteLine(sb.ToString().Trim());
    }
}

public class GraphAlgorithms
{
    //Тот самый метод поиска.
    //Основан на поиске в глубину.
    //В аргументы передаётся номер вершины которую надо найти (в вызывающем коде это всегда 1)
    //и граф в котором искать.
    public static SortedSet<int> SearchElementByDfs(Graph graph, int id)
    {
        //SortedSet<int> - бинарное дерево (красно-чёрное под копотом).
        //В нём будут храниться вершины компоненты связностии, в которой будет найдена единица.
        //Оно же и будет возвращено методом.
        //Хранение ответа в такой структуре обслувлено тем что
        //по условию задачи необходимо вывести веришны компоненты связности по возрастанию;
        //чтобы не хранить ответ в неупорядоченом списке, а потом сортировать,
        //думаю, будет лучше сразу всё сохранять в упорядоченном виде.
        SortedSet<int> result = [];

        //Массив посещённых веришн. Все значение по дефолту - false.
        var visited = new bool[graph.Count];

        //Станет true когда вершина с указанным номером (1) будет найдена.
        var found = false;

        //Перебор всех вершин в графе. Тип переменной node - Node.
        foreach (var node in graph.Nodes.Values)
        {
            //Поиск в глубину из текущей веришны.
            dfs(node);

            //Если после поиска была найдена вершина - вернуть результат,
            //если нет - обновить дерево (результат).
            if (found) return result;
            result = [];
        }
        return result;

        //Поиск в глубину. На вход принимает вершину
        //из который будет произведён поиск.
        //Реккурентная.
        void dfs(Node current)
        {
            //Если вершина уже была посещена - выйти.
            if (visited[current.Id - 1]) return;

            //Если номер текущей веришны совпадает с искомой - записать true в found. 
            if (current.Id == id) found = true;

            //Пометка текущей вершины как посещённой.
            visited[current.Id - 1] = true;

            //Добавление номера врешины в рузльтат.
            result.Add(current.Id);

            //Перебор всех соседей текущей вершины с последующим вызовом поиска на каждого из них.
            foreach (var neigthbour in current.Neightbours) dfs(neigthbour);
        }
    }
}

public class Graph
{
    //Свойство aka getter, можно воспринимать просто как поле класса.
    //При обращении возвращает количество вершин в графе.
    public int Count { get { return Nodes.Count; } }

    //Dictionary aka HashMap или словарь из питона.
    //Ключ (тип int) - номер вершины, значение (тип Node) - вершина.
    public Dictionary<int, Node> Nodes { get; }

    //Конструктор графа.
    //В graphRepr передаётся перечисление ребёр (в вызывающем коде сюда передаётся список рёбер)
    //В size передаётся количество вершин в графе.
    public Graph(IEnumerable<Connection> graphRepr, int size)
    {
        //Инициализация словаря.
        Nodes = new(size);

        //На основании ребёр строится граф.
        foreach (var conn in graphRepr)
        {
            //Добавление в граф новых вершин.
            //Имеется защита от дублирования.
            Add(conn.Id1);
            Add(conn.Id2);

            //Соединяет веришны.
            //Устраняет петли и кратные рёбра.
            Connect(conn.Id1, conn.Id2);
        }
    }

    //Метод добавления новой врешины в граф.
    public void Add(int id)
    {
        //Если в графе есть вершина с таким номером - ничего не делать и выйти.
        if (Nodes.ContainsKey(id)) return;

        //Создаётся новая вершина с указанным номером и добавляется в словарь под своим же номером.
        Nodes.Add(id, new Node(id));
    }

    //Метод соединения двух вершин.
    public void Connect(int id1, int id2)
    {
        //Защита от петли.
        if (id1 == id2) return;

        //Довольно сложная для прочтения конструкция.
        //В кратце если один из двух номеров вершин не будет найден в текущем графе, то произойдёт выход из метода.
        //Так же здесь создаются две переменные - node1 и node2.
        //В случае если в графе найдутся веришны с указанными номерам,
        //то в них будут записаны значения этих вершин (экземпляры класса Node).
        if (!(Nodes.TryGetValue(id1, out Node? node1) && Nodes.TryGetValue(id2, out Node? node2))) return;

        //Присоединение вершин друг к другу.
        //Так как каждая веришна имеет свой список соединений, граф можно считать ориентированым,
        //именно поэтому соедение происходит на обеих веришанх, чтобы был путь из node1 в node2 и из node2 в node1.

        //|-------| -----> |-------|
        //| node1 |        | node2 |
        //|_______| <----- |_______|

        //Так как Neightbours это HashSet, такое явление как кратные рёбра исключено.
        node1.Neightbours.Add(node2);
        node2.Neightbours.Add(node1);
    }
}

//Класс вершины. В конструктор передаётся номер вершины.
public class Node(int id)
{
    //Возвращает номер вершины
    public int Id { get; } = id;
    
    //Содержит в себе вершины с которыми есть соединение.
    //Значение уникальны т.к. HashSet.
    //В С# все ссылочные типы наследуются от object,
    //который имеет в себе несколько методов с дефолтной имлпементацией и
    //которые можно переписать в производных классах.
    //int GetHashcode() один из них. Он возращает хэш-код (типа int) класса - прзнак уникальности
    //на который полагаются такие коллекции с хэшированием как HashSet или Dictionary.
    //В данном классе он переписан. Реализацию можно увидеть ниже.
    public HashSet<Node> Neightbours { get; } = [];

    //В качестве хэш-кода возращает номер вершины.
    //Так что даже если два разных экзмепляра будут иметь одинаковый номер,
    //они будут иметь одинаковый хэш-код и для HashSet будут одним и тем же.
    public override int GetHashCode() => Id;

    //Метод добавления вершин с которыми текущая вершина должна быть соединена.
    public void AddNeightbours(params Node[] nodes)
    {
        foreach (var node in nodes) Neightbours.Add(node);
    }
}

//Структура ребра.
//Используются только для получения информации о рёбрах из ввода
//и дальнейшей передачи в конструктор графа.
//Id1 - номер первой врешины
//Id2 - номер второй врешины
public readonly struct Connection(int id1, int id2)
{
    public int Id1 { get; } = id1;
    public int Id2 { get; } = id2;
}
